# プログラムの説明


## main関数内の大きな流れ
- 2048ゲームの盤面として**4*4の二次元配列board**を用意する。
- オリジナル要素の一つとして、**動く障害物**を数字の１として生成。
- **appear関数**で初期の２つの数字の配置を決める。
- 初期の盤面を標準出力する。
- while文では、キーボードで'　.　'を入力しない限り、以下を繰り返す
0. キーボードからk, m, j, iのいずれかを受け取ったら以下を実行
1. **sort関数**で指定の方向に盤面の**数字の配置をずらす**
2. **calliculate関数**で隣り合った数字が同じ場合は**合体**して和をとる。
3. 再びsort関数で空白を埋める。
4. 1.及び3.のsortで一度も移動が起きていなかったら**0.に戻り**別の文字を受け取る。（動けない方向のキーの入力は無効）(下記に詳細に説明)
4. 空白に新しく2か4を生成。（オリジナル要素:確率10%で生成せずもう一度動かせる（BONUS））
5. このとき**空白が0個かつ隣り合う同じ数のペアが一つもなければゲームオーバー**。また、2048以上があればクリアと表示する（なおゲームは続行）。

```c
int blank=0;                //空白が存在するかどうか
for(int n=0;n<4;n++){           //for文で空白の数を計算
    for(int m=0;m<4;m++){
        if(board[n][m]==0){
            blank++;
        }
        if(board[n][m]>=2048){
            blank-=20;          //2048以上があるときbrankを負とする
        }
    }
}
int possible=0;             //同じ数字が隣り合っているかどうか
if(blank<0){                //2048以上でクリアとする
    printf("GAME CLEAR!\r\n");
}else if(blank==0){                                 //空白0個の場合
    for(int n=0;n<4;n++){　　　　                    //for文を二回回して隣り合う同じ数が存在するかどうかを計算
        for(int m=0;m<3;m++){
            if(board[n][m]==board[n][m+1]){possible++;}
        }
    }
    for(int n=0;n<4;n++){
        for(int m=0;m<3;m++){
            if(board[m][n]==board[m+1][n]){possible++;}
        }
    }
    if(possible==0){                                //空白0個のかつ隣り合う同じ数のペアが0個の場合ゲームオーバー
        printf("GAME OVER...\r\n");
    }
}
```
6. 新しい盤面を表示





## 関数print_boardについて
- 引数として盤面のデータ（4*4の二次元配列board）を受け取る。
- 二重for文により盤面を標準出力する。


## 関数appearについて
- 2または4をランダムに空いている場所に生成する関数。
```c
void appear(int board[][4]){//引数として盤面のデータboardを受け取る。
    int x=rand()%4;    
    int y=rand()%4;         //0~３の数字を二つランダムに生成しx,yとする
    while(board[x][y]!=0){  //(x,y)が盤面上で空白でなければ繰り返しランダム生成
        x=rand()%4; y=rand()%4;
    }
    if(rand()%10==0){
        board[x][y]=4;      //確率10%で４を生成
    }else{
        board[x][y]=2;      //90%は2を生成
    }
}
```

## 関数sortについて
- 引数として数字を動かす方向を区別する文字'c'と盤面boardを受け取る。
- 返り値はsortした回数を返す。（sort回数は盤面の数字が動くかどうか判断するために返す。while内の二回のsort関数でsort回数が両方とも0回の場合、キーボードから他の’c’を受け取る。）

```c
int sort(int c,int board[][4]){
    int movement=0;　           //sort回数
    for(int n=0;n<4;n++){
        for(int r=0;r<3;r++){               //rによるループについては下記参照
            for(int m=0;m<3;m++){
                if(c=='k'){                 //数字を右に動かす場合
                    if(board[n][m]!=0&&board[n][m+1]==0){//注目している０でない数字の右側にある数字が０の場合
                        board[n][m+1]=board[n][m];  //入れ替える
                        board[n][m]=0;
                        movement++;                 //一回sortした
                    }
                }else if(c=='m'){           //数字を下に動かす場合
                    if(board[m][n]!=0&&board[m+1][n]==0){
                        board[m+1][n]=board[m][n];
                        board[m][n]=0;
                        movement++;
                    }
                }else if(c=='j'){           //数字を左に動かす場合
                    if(board[n][m]==0&&board[n][m+1]!=0){
                        board[n][m]=board[n][m+1];
                        board[n][m+1]=0;
                        movement++;
                    }
                }else if(c=='i'){           //数字を上に動かす場合
                    if(board[m][n]==0&&board[m+1][n]!=0){
                        board[m][n]=board[m+1][n];
                        board[m+1][n]=0;
                        movement++;
                    }
                }
            }   
        }
    }
    return movement;
}

```
- rのループは,例えば１行目の[2,2,2,0]を右にずらす場合、上記のやり方だと同じ行を3回ループする必要があるため。([2,2,2,0]→[2,2,0,2]→[2,0,2,2]→[0,2,2,2])

## 関数calliculateについて
- 引数として数字を動かす方向を区別する文字'c'と盤面boardを受け取る。
- 例えば右方向に数字を動かす時、一度main内のsortで空白を詰めて数字を右側に寄せている。このとき隣り合う数字が同じ場合はこのcalliculate関数で合体して二倍にする。
- 右方向に動かす場合のコードを下に示す（他の方向についても同じ）
```c
void calliculate(int c,int board[][4]){
    for(int n=0;n<4;n++){
        if(c=='k'){                     //右に動かす場合
            if(board[n][3]==board[n][2]){   //右端とその左の数が同じ場合(ex:[0,0,2,2])
                board[n][2]*=2;             //左のほうを二倍して、
                board[n][3]=0;              //右端を0とする(ex:[0,0,4,0])*下記参照
                if(board[n][1]==board[n][0]){//さらに左端とその右の数が同じ場合
                    board[n][1]*=2;    //右のほうを0として、
                    board[n][0]=0;     //左端を0とする
                }
            }else if(board[n][2]==board[n][1]){ //中間の二つが同じ場合(ex:[0,2,2,4])
                board[n][1]*=2;                 //やはりの左のほう二倍して、
                board[n][2]=0;                  //右側は0とする(ex:[0,4,0,4])＊
            }else if(board[n][1]==board[n][0]){//左端とその右の数が同じ場合(ex:[2,2,4,8])
                board[n][0]*=2;                 //やはりの左のほう二倍して、
                board[n][1]=0;                  //右側は0とする(ex:[4,0,4,8])＊
            }
```
- ＊について
    - exに示した[0,0,4,0]や[0,4,0,4]のように、このcalliculate関数で数字を合体させた場合、必ずもう一度sortして数字を詰めさせる必要があるように計算している。つまり、＊の部分のコードで右側の数字を2倍しないようにしている。もし右側の数字を2倍にするようなコードを書くと：
        - 例えば１行目が[0,0,2,2]の状態でキーボードで’k’を入力し右に詰めようとすると,[0,0,0,4]となり,この後一回もsortしなくてよいことになる。即ちcalliculateを実行する前後で二回sortするものの,二回とも返り値が0となる。main関数の手順4の通り, キーボード入力が有効かどうかはsortが0回以上かどうかで判断しているため,　ここでは無効と判断されてしまい,　正しく動作しない。
        - ちなみに、calliculate内で合体した回数を数えてこの数をキーボード入力が有効かどうかの判断材料としてもうまくいかない。なぜならcalliculate内で密かに0と0が隣り合う場合でも合体しているからである。

